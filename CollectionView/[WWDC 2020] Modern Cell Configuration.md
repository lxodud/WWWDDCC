# [WWDC 2020] Modern Cell Configuration

[Modern cell configuration - WWDC20 - Videos - Apple Developer](https://developer.apple.com/videos/play/wwdc2020/10027/)

iOS 14에서는 UiCollectionView에 새로은 기능을 제공함

데이터를 채우는 방식, 레이아웃을 정의하는 방식, 콘텐츠를 표시하는 방식 세 가지 범주로 크게 구성할 수 있다.

![](https://velog.velcdn.com/images/xoxo0223/post/adb963bc-c03a-4050-8866-ada8ddec7ae5/image.png)


이 세션에서는 셀의 콘텐츠 및 스타일을 구성하는 새로운 API인 View configuration에 중점을 둘 것이다.

![](https://velog.velcdn.com/images/xoxo0223/post/946b03c7-b59d-4a2b-91d7-8d992c3aa7e0/image.png)


새로운 configuration을 사용하여 셀을 설정하는 것이 얼마나 쉬운지 살펴보는 것으로 시작한다고함

그리고 configuration state라는 새로운 개념에 대해 자세히 살펴본다함

이 개념은 configuration과 함께 작동하여 다른 상태에 대해 다른 모양을 쉽게 얻을 수 있도록 함

마지막으로 backgroun, content configuration의 두 가지 구성 타입을 자세히 살펴보고 이를 사용하는 방법을 자세히 다룬다고함

최신 셀 구성 API에 들어가기 전에 iOS 13에서 테이블 뷰 셀을 구성하는 방법에 대한 예를 간단하게 살펴보자

![](https://velog.velcdn.com/images/xoxo0223/post/94759826-c753-478d-b33b-da293f6e0dfa/image.png)


위와 코드를 자주 봤을 꺼임

UITablbleViewCell의 내장 프로퍼티를 사용함

이것은 셀 구성이 무엇을 의미하는지 보여주는 간단한 예이다.

새로운 configuration API를 사용하여 동일한 작업을 수행하는 방법을 살펴보자

![](https://velog.velcdn.com/images/xoxo0223/post/e841fb8e-7871-4b27-a5ef-7a366dc61a95/image.png)


요것이 content configuration을 사용하여 셀을 구성하는 방법이다.

두 줄의 새로운 코드가 있음

가장 먼저 할 일은 셀에 defaultContentConfiguration을 요청하는 것이다.

이것은 항상 콘텐츠가 설정되지 않은 새로운 구성을 반환한다.

그러나 이 구성에는 셀 및 테이블 뷰 스타일을 기반으로 하는 기본 스타일이 있다.

콘텐츠 구성에 이미지와 텍스트를 설정해줌

그리고 cell의 contentConfiguration 프로퍼티에 할당해줌

이렇게 하면 지정한 이미지와 텍스트를 표시하도록 셀이 업데이트 된다.

이제 이 코드 줄 이전에 이미지와 텍스트를 설정하면 이 콘텐츠 변수에 저장된 구성의 로컬 복사본만 변경되었다.

Content configuration을 사용하고 있기 때문에 UIImageView 또는 UILabel을 직접 건드리지 않는다!!

모든 프로퍼티는 구성 자체에서 설정된다.

콘텐츠 구성을 사용하여 셀을 설정함으로써 무엇을 얻었는가?

![](https://velog.velcdn.com/images/xoxo0223/post/4a85bf34-95b8-4918-893d-40b4965e57ad/image.png)


우선 테이블 뷰 셀을 구성하기 위해 여기에서 볼 수 있는 코드는 실제로 컬렉션 뷰 셀과 같은 셀을 구성하는 데 사용하는 것과 동일한 코드이다.

실제로 동일한 코드는 콘텐츠 구성을 지원하는 모든 뷰에 대해 작동하고 헤더나 푸터와 같이 셀이 아닌 경우에도 작동한다.

이것이 어떻게 가능한가?

이는 configuration이 composable하기 때문임

모든 기능이 UITableViewCell에서와 같이 셀 클래스 자체에 구어지는 대신 표준 셀 레이아웃 및 모양을 지원하는 모든 셀 또는 뷰에 바로 연결할 수 있는 독립적인 조각으로 사용할 수 있다.

구성을 사용하여 얻을 수 있는 다른 이점을 아라보자

![](https://velog.velcdn.com/images/xoxo0223/post/135056cd-db70-4986-947c-ee1046e2d1ac/image.png)


새로운 사이드바 모양을 사용하는 컬렉션 뷰 리스트에 셀이 있음

셀에 우리가 구성한 별 이미지와 텍스트가 있는 것을 볼 수 있다.

이제 우리가 이 셀과 상호 작용하기 시작하면 ~~~

![](https://velog.velcdn.com/images/xoxo0223/post/d8a4a41f-0d17-474e-b29f-1905e44c9d94/image.png)


셀을 터치하면 강조 표시된 모양이 표시된다.

![](https://velog.velcdn.com/images/xoxo0223/post/127d9212-ce74-458c-98d3-a3ee7f5ba17d/image.png)

셀을 들어올리면? 셀이 선택된다.

이것들은 셀이 있을 수 있는 몇 가지 다른 상태일 뿐이므로 셀을 더 추가하고 셀의 모양이 어떻게 변하는지 확인해보자

<img width="472" alt="스크린샷 2022-12-22 오전 1 12 45" src="https://user-images.githubusercontent.com/85005933/220128794-93e7f038-5fc7-440e-a02d-8b722f42e780.png">


위 그림은 동일한 content configuration이지만 서로 다른 상태의 서로 다른 모든 셀에 적용 된다.

이 셀의 텍스트를 교체하여 각 셀의 상태를 표시해보자

<img width="464" alt="스크린샷 2022-12-22 오전 1 13 44" src="https://user-images.githubusercontent.com/85005933/220128848-e4daf1bf-936b-4a6b-92d4-e84103a07b93.png">

사이드바 리스트 셀의 기본 스타일은 상태에 따라 크게 다르다.

configuration을 사용하여 셀을 설정하면 이러한 다양한 모양을 모두 자동으로 얻을 수 있다.

이것이 어떻게 작동하는지 조금 더 자세히 아라보자

구성은 콘텐츠, 스타일 지정, 메트릭 및 동작과 같은 특정 상태에 대한 뷰의 모양을 설명한다.

구성은 프로퍼티의 모음일 뿐이다.

뷰 또는 렌더링할 셀에 적용하기 전까지는 아무 작업도 수행하지 않는다.

구성은 composable하다. 구성을 지원하는 모든 타입의 셀 도는 뷰와 함께 사용할 수 있다.

구성은 background configuration, content configuration 두 가지 타입의 구성이 있다.

![](https://velog.velcdn.com/images/xoxo0223/post/e66bb1db-0ab0-4c12-b56d-f9f0c054489b/image.png)


배경 구성은 일반적인 배경 모양을 빠르게 지정할 수 있는 여러 프로퍼티가 있다.

몇 줄의 코드만으로 배경 fill color을 커스텀하고 시각적 효과를 설정하여 멋진 흐림 효과를 얻고 stroke와 둥근 모서리를 추가할 

더 많은 커스텀 작업을 수행하려는 경우 고유한 뷰를 제공하여 수행할 수 있다.

리스트 콘텐츠 구성은 테이블뷰 셀과 매우 유사한 셀, 헤더, 푸터에 대한 표준 레이아웃을 제공한다.

리스트 콘텐츠 구성은 훨씬 더 강력하다 함

이미지, 텍스트 및 선택적 보조 텍스트를 지원하고 각각에 대해 커스텀할 수 있는 많은 프로퍼티를 노출한다.

또한 더 많은 양의 텍스트를 표시할 수 있는 유연한 레이아웃과 accessibility text size를 위한 특수 레이아웃 모드와 같은 더 높은 수준의 동작을 제공한다.

이 두 가지 구성 유형은 함께 사용되고 몇 가지 공통된 설계 원칙을 갖는다.

가장 중요한 원칙 중 하나는 구성이 가볍고 제작 비용이 매우 저렴하다는 것이다.

그것들은 Swift의 값 타입이다. 즉, 구성이 있을 때마다 우리의 것이고 구성에 대한 변경 사항은 해당 구성을 셀에 설정할 때까지 다른 것에 영향을 미치지 않는다. (복사되니까!!)

구성은 가볍기 때문에 아래 코드처럼 셀에 defaultContentConfiguration을 요청하는 것과 같이 항상 새로운 구성으로 시작해야 한다.

![](https://velog.velcdn.com/images/xoxo0223/post/3df7886c-bb60-4f20-9397-1f708c561da4/image.png)


이는 셀을 처음 구성할 때뿐만 아니라 이미 구성된 셀을 업데이트할 때마다 적용된다.

매번 새로운 구성으로 시작하여 새로운 상태로 설정한다.

![](https://velog.velcdn.com/images/xoxo0223/post/38bde09e-7bcc-44ec-9e2d-8d4fec1737d0/image.png)


구성을 사용할 때 이전 상태에 대해 전혀 생각할 필요가 없다.

이전 구성이 이미 적용되었는지 여부에 대해 걱정하지 말라는 뜻!

변경하기 위해 먼저 기존 구성을 가져오려고 시도해서도 안된다!!

매번 새로운 구성으로 시작하여 원하는 방식으로 설정한 다음 셀에 적용한다!!

reuse를 신경 쓸 필요가 없다~~

UIKit을 오랫동안 사용했다면 조금 다르게 느껴질 수 있는데, 일단 이런 식으로 생각하기 시작하면 엄청나게 해방된다함

셀에 구성을 적용하면 UIKit이 모든 어려운 작업을 대신 수행한다함

무엇이 변경되었는지 파악하고 필요에 따라 뷰를 효율적으로 업데이트 한다.

구성은 다양한 상태에 대한 기본 모양을 제공함

구성은 이러한 상태 모양을 커스텀하는 데 사용할 수 있는 강력한 인프라 위에도 구축된다. 이에 대해서는 곧 자세히 설명한다함

구성은 또한 단 몇 줄의 코드로 고급 동작에 대한 액세스를 제공한다.

배경 모양에 대한 변경 사항에 애니메이션을 적용하고 싶다고 가정해보자

애니메이션 내부에 새로운 배경 구성을 설정하기만 하면된다.

구성은 사용하기 쉬울 뿐만 아니라 복잡한 상태 및 전환을 처리할 때 버그를 실제로 제거한다.

현재 적용된 구성이 truth임을 알고 있으며 새 구성이 설정하면 해당 새 구성이 한 번에 적용된다.

마지막으로 구성은 처음부터 성능을 위해 구축되었으며 이는 부드러운 스크롤을 보장하는데 특히 중요하다.

UIKit은 뷰와 렌더링을 관리하기 때문에 내부적으로 많은 내부 성능 최적화를 구현할 수 있으며 무료로 얻을 수 있다.

이제 기본 구성과 함께 작동하는 구성 상태라는 새로운 개념에 대해 이야기해보자

# configuration state

구성 상태는 셀 및 뷰를 구성하는 데 사용하는 다양한 입력을 나타낸다.

어떤 종류의 입력에 대해 이야기하고 있는가?

뷰를 설정하는 방법을 결정하는 가장 일반적인 입력 중 하나는 UITraitCollection의 특성이다.

크기 클래스, UI 스타일 및 콘텐츠 크기 카테고리 같은 것이다.

이러한 특성 외에도 셀과 뷰는 다양한 상태로 존재한다.

![](https://velog.velcdn.com/images/xoxo0223/post/ea3a9ca0-25cc-4797-8e4c-aaa609130d6b/image.png)

셀이 선택되었거나 끌어서 놓기 대상이거나 일시적으로 비활성화되었을 수 있다.

이들은 UIKit에서 흔히 볼 수 있는 다양한 상태 중 일부일 뿐이다.

이러한 상태 외에도 앱에는 커스텀한 상태가 있다.

이들은 앱과 해당 도메인에 특정하게 사용하는 모든 다양한 상태이다.

예를 들어 셀을 구성할 때 메시징 앱은 메시지가 보관되었는지 또는 플래그가 지정되었는지 여부를 알아야 하고 결제 앱은 처리된 트랜잭션을 표시할 수 있다.

뷰 모델을 사용하여 셀을 콘텐츠로 채우는 경우 해당 뷰 모델을 사용자 정의 상태로 생각할 수도 있다.

이러한 모든 것이 configuration state를 구성하는 것이다.

그렇다면 구성 상태는 어디에서 찾을 수 있을까?

![](https://velog.velcdn.com/images/xoxo0223/post/b0f91852-9992-47bd-8e1f-18614defd7f8/image.png)


컬렉션 또는 테이블 뷰의 각 셀, 헤더 푸터에는 고유한 구성 상태가 있다.

위 그림에서는 3개의 셀이 표시되고 각 셀은 구성 상태에서 다른 항목을 가질 수 있다.(각각 다른 상태일 수 있다는 뜻인 것 같음)

구성 상태는 어떤 모습일까?

두 가지 유형이 있다.

헤더와 같은 뷰에 대한 구성 상태 타입이 있고 셀에는 다른 타입이 있음

![](https://velog.velcdn.com/images/xoxo0223/post/294cc09a-fe26-4dab-a18c-08d6b497bf87/image.png)


뷰 구성상태는 위 그림과 같음

trait collection으로 시작한 다음 4가지 상태가 있음 이들은 단순한 Bool 타입임

마지막으로 옵셔널 커스텀 상태가 있음

뷰를 구성할 때 사용하려는 추가 상태나 데이터를 추가할 수 있는 키-값 저장소이다.

![](https://velog.velcdn.com/images/xoxo0223/post/c65485e6-ab21-42b5-ae42-4eda93042284/image.png)


셀은 다음과 같음

뷰 구성 상태에서 모든 것을 가져오고 일부 상태가 추가됌!!

![](https://velog.velcdn.com/images/xoxo0223/post/36271d7a-ecbf-45a5-b21f-6bc4fcf11b12/image.png)


구성 상태로 수행할 수 있는 가장 중요한 작업 중 하나는 이를 사용하여 새 상태에 대한 구성을 업데이트하는 것이다.

다른 구성 상태에 대해 업데이트된 버전을 반환하도록 배경 또는 콘텐츠 구성에 요청할 수 있다.

이렇게 하면 새 상태를 반영하도록 업데이트된 속성과 함께 구성의 새 복사본이 반환된다.

예를 들어 배경 구성은 배경색을 변경할 수 있고 콘텐츠 구성은 이미지 색조 색상 과 텍스트 색상을 변경할 수 있다.

업데이트된 구성을 요청할 때 원래 구성은 변경되지 않는다.

또한 원래 구성에서 프로퍼티를 커스텀한 경우 해당 프로퍼티는 업데이트된 구성에서 동일하게 유지된다.

일단 프로퍼티를 설정하면 구성의 프로퍼티가 잠긴 것으로 생각할 수 있다.

![](https://velog.velcdn.com/images/xoxo0223/post/a069e011-9e3b-4e63-a58c-ada2724a1283/image.png)

세션 시작부분에서 다양한 상태에 대한 모양을 업데이트하는 아이패드 앱을 떠올려봐라

그게 자동 구성 업데이트로 인해 작동했다.

기본적으로 셀 배경 또는 콘텐츠 구성을 설정하면 셀의 구성 상태가 변경될 때마다 자동으로 업데이트된 버전을 반환한 다음 해당 새 구성을 다시 셀에 적용하도록 구성에 요청한다.

이러한 프로퍼티를 사용하면 이 동작을 제어할 수 있다.

자동 업데이트는 각 상태에 대한 기본 스타일을 얻는 데 유용하지만 다른 상태에 대한 모양을 사용자 지정하려는 경우 자동 업데이트를 비활성화하고 구성을 직접 업데이트할 수 있다.


![](https://velog.velcdn.com/images/xoxo0223/post/e812d239-0b87-44d4-9574-382d994e9828/image.png)

하지만 이러한 구성을 업데이트하는 코드를 어디에 두어야 할까?

컬렉션 및 테이블 뷰 셀에 updateConfiguration(using state)에 둔다.

이것은 전달된 상태를 기반으로 셀을 구성하는 코드를 넣을 수 있는 셀 하위 클래스에서 재정의하는 방법이다.

이 메서드는 셀이 처음 표시되기 전에 항상 호출되며 구성 상태가 변경될 수 있을 때마다 다시 호출되므로 새 상태에 맞게 구성할 수 있다.

구성은 구성을 설정하고 셀에 적용하는 작업을 코드에 한 곳에서 처리할 때 가장 잘 작동한다.

커스텀 셀 하위 클래스를 사용하는 경우 위 메서드가 가장 적합한 장소라고함

이 방법은 셀에 대한 다른 설정이나 업데이트를 중앙 집중화할 수 있는 좋은 장소이기도 한다.

예를 들어 새 컬렉션 뷰 리스트 셀을 사용하는 경우 이 방법을 사용하여 다른 상태에 대한 셀 액세서리의 색조 색상을 업데이트할 수 있다.

어떤 이유로든 셀을 재구성해야 하는 경우 setNeedsUpdateConfiguration을 호출하여 업데이트를 요청하면 된다.

이 방법을 사용하여 셀을 설정하고 다양한 상태에 대한 구성을 수동으로 업데이트하는 방법의 예를 살펴보자

![](https://velog.velcdn.com/images/xoxo0223/post/d0dacc05-a65d-4011-be48-3a8ecaf47e4f/image.png)

먼저 셀의 기본 콘텐츠 구성을 요청

새 상태에 대해 즉시 업데이트

이것은 이 상태에 대한 시스템 기본 스타일로 구성을 제공할 꺼임

다음으로 셀이 표시하는 항목에 대한 구성의 이미지와 텍스트를 설정함

상태가 강조나 선택일 경우 이미지 틴트 컬러와 텍스트의 색을 흰색으로 설정함

마지막으로 구성을 셀에 설정해줌

이 메서드는 상태가 변경될 때마다 다시 호출되고 매번 새 상태에 대한 새 구성을 적용함

여기서도 백그라운드 구성을 커스텀할 수 있음

위 예제에서는 특정 상태에서 이미지와 텍스트에 대해 서로 다른 색상을 설정하는데 색상 변환기라는 새로운 타입을 사용하여 다른 상태에서 색상의 모양을 변경하는 방법이 있음

![](https://velog.velcdn.com/images/xoxo0223/post/900c0702-ec56-4da2-9330-bc11fee58c03/image.png)


색상 변환기는 한 가지 색상을 가져와서 어떤 식으로든 원래 색상을 수정하여 다른 색상을 반환함

예를 들어 색상의 회색조 버전을 반환하는 색상 변환기가 있을 수 있음

따라서 색상 변환기는 단순한 기능일 뿐임

그러나 색상 변환기는 매우 강력하다함. 다른 색상 변호나기를 사용하여 동일한 입력 생상에서 다양한 변형을 생성할 수 있기 때문이라함 (뭔 소린지 모르겠음)

이것이 색상 변환기를 사용하여 상태에 따라 다른 모양을 만드는 방법이다.

특정 스타일 및 상태에 대한 일부 기본 구성에는 해당 상태에 대한 특정 모양을 생성하기 위해 미리 설정된 색상 변환기가 있다.

색상 변환기는 입력 색상과 결합하여 실제로 보이는 분해 색상을 생성한다.

색상 변환기에 대한 설명은 나중에 공부해보자,,,,

## 이제 background configuration, content configuration의 세부 정보를 다룬다함

![](https://velog.velcdn.com/images/xoxo0223/post/ec95e664-9016-42a3-adce-39436db568ca/image.png)


컬렉션뷰 리스트 셀, 테이블 뷰 셀 및 헤더 푸터는 자신을 포함하는 리스트 또는 테이블 뷰의 스타일을 기반으로 기본 배경 구성을 자동으로 설정한다함

일반적으로 원하는 배경 모양을 얻기 위해 아무것도 할 필요가 없음

콘텐츠 구성은 조금 다르게 작동함

셀이 기본적으로 자동으로 적용하는 대신 새로운 구성을 가져올 수 있음

UIBackgroundConfiguration 및 UIListContentconfiguration 타입으로 직접 이동하여 원하는 스타일에 대한 기본 구성을 쉽게요청할 수도 있음

위 코드는 사이드바 스타일 리스트 셀에 대해 이 작업을 수행하는 방법의 예를 볼 수 있다.

셀 헤더 푸터에도 비슷한게 있다함

다양한 스타일을 실제로 살펴보자

스티커 카테고리 리스트가 있음

![](https://velog.velcdn.com/images/xoxo0223/post/c597b0c2-2be4-4993-8de8-ab4c9210e1fc/image.png)

이 리스트는 현재 사이드바 모양으로 구성되어 있으므로 모든 셀에는 해당 스타일과 일치하는 기본 배경 및 콘텐츠 구성이 있음

셀과 상호작용할 때 셀이 다른 상태에 대한 배경 및 콘텐츠 모양을 업데이트하는 것을 볼 수 있다.

그러나 사이드바 스타일은 컬렉션 뷰 리스트에 사용할 수 있는 모양 중 하나일 뿐이다.

이를 몇 가지 다른 모양으로 구성하면 어떤 일이 발생하는지 살펴보자

![](https://velog.velcdn.com/images/xoxo0223/post/91c84e25-9475-4d9f-928d-126dba612ccf/image.png)


이건 grouped 모양으로 구성

![](https://velog.velcdn.com/images/xoxo0223/post/b2f596d7-f9a7-4776-ac15-88dfef5b0ad8/image.png)


inset grouped

![](https://velog.velcdn.com/images/xoxo0223/post/84f35d95-9152-4cfd-b3e7-1d84565add9c/image.png)


plain

뭐 여러가지 모양들이 있고 거기에 백그라운드, 콘텐츠 구성이 사용된다함!

이제 개별 셀을 더 명확하게 보고 시스템 텍스트 크기 설정을 변경하여 서로 다른 동적 타입 크기에 어떻게 반응하는지 살펴본다함

기본적으로 모든 것이 이러한 변경 사항에 동적으로 반응하는 것을 볼 수 있음

텍스트 크기를 늘리면 전체 레이아웃이 조정되고

가장 큰 텍스트 크기를 켜면 셀 레이아웃이 콘텐츠에 사용할 수 있는 공간을 최대화하기 위해 텍스트가 이미지 주위를 감싸는 특수 모드를 사용하는 것을 볼 수 있다.

![](https://velog.velcdn.com/images/xoxo0223/post/887e6e0b-26dc-446a-9077-e64c1a0848ca/image.png)


콘텐츠 구성은 이와 같은 동적 레이아웃을 지원하기 위해 처음부터 구축되는데 어떻게 작동하는지 아래에서 설명해준다함

![](https://velog.velcdn.com/images/xoxo0223/post/506a89c6-1e04-4917-9027-3c346831e0e8/image.png)

콘텐츠 구성은 정확한 구성 및 환경에 따라 높이가 유연할 수 있는 self-sizing 셀과 함께 사용하도록 설계되었다.

이것은 다양한 장치 크기, 다양한 동적 타입 크기 및 다양한 양과 타입의 콘텐츠로 앱을 실행할 때 멋지게 보이도록 하는 데 중요하다.

콘텐츠 구성을 통해서 파란색으로 표시된 레이아웃 여백과 주황색으로 표시된 다양한 패딩 속성을 제어할 수 있다.

실제 콘텐츠와 함께 이들은 고유 높이를 결정하고 셀의 self-sizing에 영향을 준다.

고정된 높이를 적용하는 대신 콘텐츠 구성에서 이러한 속성을 사용하여 레이아웃에 영향을 주고 높이를 동적으로 저장할 수 있도록 해야 한다. 

알아야 할 레이아웃 개념이 하나 더 있다.

![](https://velog.velcdn.com/images/xoxo0223/post/fb401e00-1096-4cc2-9e38-375143a9155c/image.png)


위 그림에는 이미지와 일부 텍스트가 포함된 콘텐츠 구성을 사용하는 세 개의 서로 다른 셀이 있다.

지금은 괜찮음

근데 우리가 이 셀들에서 몇몇 다른 이미지를 사용하고 싶다고 가정해보자

![](https://velog.velcdn.com/images/xoxo0223/post/698643ce-665f-4233-ae9a-83ed25d6106c/image.png)

문제는 이미지가 정확히 같은 크기가 아니라는 것이다.

너비가 약간 다르다.

따라서 이미지와 텍스트는 더 이상 셀 간에 정렬되지 않는다.

![](https://velog.velcdn.com/images/xoxo0223/post/3ac1b97f-51fa-457d-aef8-860c732a80ec/image.png)


이런 일이 발생한 이유는 이미지가 선행 정렬되고 텍스트가 각 이미지의 후행 가장자리에서 동일한 양의 패딩으로 배치되기 때문이다.

![](https://velog.velcdn.com/images/xoxo0223/post/75b44241-4692-4e4c-8804-84fd924f85d2/image.png)


이러한 셀에서 올바른 정렬을 얻으려면 각 이미지에 대해 예약된 레이아웃 크기라고 하는 것을 지정해야 한다.

reserved layout size

각 콘텐츠 구성에서 이미지에 대해 동일한 예약된 레이아웃 너비를 설정하면 예약된 공간 내에서 이미지를 가로로 중앙에 배치한다.

이 그림에서 두 개의 빨간색 점선 사이의 거리는 각 이미지에 대해 예약된 레이아웃 너비이다.

예약된 레이아웃 크기는 이미지의 실제 크기에 영향을 주지 않는다.

그리고 이미지가 예약된 레이아웃 크기보다 큰 경우 해당 영역 밖으로 확장할 수 있다.

이미지에 대해 예약된 레이아웃 크기를 사용하면 텍스트가 각 셀의 이미지에 대해 동일한 예약된 레이아웃 영역을 기준으로 배치되기 때문에 텍스트도 올바르게 정렬된다.

symbol image를 사용하는 경우 UIKit은 예약된 표준 레이아웃 크기를 자동으로 적용하므로 필요한 경우 기호가 아닌 이미지를 수동으로 요청할 수 있다.

구성 채택을 시작할 때 염두에 두어야 할 몇 가지 중요한 세부 정보를 아라보자

![](https://velog.velcdn.com/images/xoxo0223/post/8c417ed9-101b-484b-a9df-87e46609c17c/image.png)


업데이트 및 마이그레이션 하는 기존 코드가 있는 경우 구성이 일부 기존 프로퍼티와 상호 배타적이라는 점에 유의하자

배경 구성을 설정하면 항상 배경색과 배경 뷰의 프로퍼티가 nil로 재설정 된다.

그 반대도 마찬가지라함

따라서 동일한 셀에서 이러한 다른 배경 프로퍼티를 여전히 설정하는 다른 코드와 배경 구성을 혼합하지 않도록 하자

![](https://velog.velcdn.com/images/xoxo0223/post/c51d2624-d703-4979-a0ff-8f7b6f1a14b5/image.png)


특히 UITableView를 사용하는 사용자를 위해 콘텐츠 구성은 imageView, textLabel, detailTextLabel과 같은 셀, 헤더 푸터의 기본 제공 하위 뷰를 대체한다.

이러한 레거시 콘텐츠 프로퍼티는 deprecated 될꺼니까 콘텐츠 구성을 채택해서 보다 강력한 기능과 향상된 사용자 지정 가능성을 활용하는 것이 좋다.

오늘 다룬 두 구성은 매우 강력함

그러나 더 많은 커스텀 작업을 수행해야 하는 경우가 여전히 있다.

구성을 통해 이전보다 더 많은 옵션을 사용할 수 있다.

![](https://velog.velcdn.com/images/xoxo0223/post/73ff348a-530e-4f60-9309-5ddb43052880/image.png)


콘텐츠 구성 외에도 모든 렌더링을 구현하는 associated list content view에 대한 액세스 권한도 제공한다.

구성을 사용하여 이 뷰를 생성하거나 업데이트한 다음 자신의 커스텀 뷰 바로 옆에 하위 뷰로 추가할 수 있다.

이를 통해 모든 콘텐츠 구성 기능을 활용하고 리스트 콘텐츠 뷰를 추가 이미지 뷰 또는 레이블과 같은 추가 커스텀 뷰와 결합할 수 있다.

그러나 리스트 콘텐츠 뷰는 일반 UIView일 뿐이므로 일반 UIStackView와 같은 컬렉션 또는 테이블 뷰 외부에서도 실제로 어디서나 자체적으로 사용할 수 있다.

리스트를 전혀 작성하지 않거나 완전히 커스텀 작업을 수행하려는 경우는 어떤가?

![](https://velog.velcdn.com/images/xoxo0223/post/9d6ecf2f-7515-4efc-940c-b3404dca4cf6/image.png)


셀 내부에 완전히 커스텀한 뷰 계층 구조를 구축하는 경우에도 여전히 시스템 구성을 사용하여 도움을 받을 수 있다.

구성은 매우 가볍기 때문에 구성 자체를 직접 적용하지 않더라도 커스텀 뷰에 복사하는 글꼴, 색상 및 여백과 같은 항목에 대한 기본값의 소스로 사용할 수 있다.

고급 사용 사례의 경우 쌍을 이루는 콘텐츠 뷰 클래스를 사용하여 커스텀 콘텐츠 구성 타입을 생성한 다음 리스트 콘텐츠 구성을 사용하는 것과 동일한 방식으로 임의의 셀에서 커스텀 구성을 사용할 수 있다.

사용자 지정 구성을 사용하면 새 상태에 대해 자동으로 업데이트되도록 허용하는 것을 포함하여 지금까지 언급한 모든 기능을 활용할 수 있다.

셀이 아무리 복잡하거나 맞춤화 되어있어도 구성 기능을 사용할 수 있다.
