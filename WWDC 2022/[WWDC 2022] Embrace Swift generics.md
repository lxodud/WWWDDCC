# WWDC2022 Embrace Swift generics



[WWDC2022 Embrace Swift generics](https://developer.apple.com/videos/play/wwdc2022/110352/)

제네릭은 Swift에서 추상 코드를 작성하는 기본 도구로 코드가 진화할수록 복잡성을 관리하는 데 매우 중요하다.

![](https://i.imgur.com/S4WbjW8.png)

추상화는 아이디어를 구체적인 세부 사항과 구분한다.

우리가 항상 사용하는 추상화의 한 가지 형태는 코드를 함수나 로컬 변수로 분해하는 것입니다. (분해?)

![](https://i.imgur.com/FrqKJjw.png)

이는 동일한 기능이나 값을 여러 번 사용해야 하는 경우 매우 유용합니다.

![](https://i.imgur.com/xlTa0RT.png)

기능을 함수로 추출하면 세부 정보가 추상화되며 이 추상화를 사용하는 코드는 세부 정보를 반복하지 않고 현재 일어나고 있는 일에 대한 아이디어를 표현할 수 있다. (함수명으로 아이디어를 표현!!)

Swift에서는 구체적인 타입도 추상화할 수 있습니다.

![](https://i.imgur.com/T2jJwIX.png)

서로 다른 세부 정보를 가진 동일한 아이디어의 타입 집합이 있는 경우 추상 코드를 작성하여 모든 구체적인 타입과 함께 작업할 수 있습니다.

![](https://i.imgur.com/IBtuOA3.png)

이 세션에서는 살펴볼 것은 아래와 같습니다.

- 구체적인 타입을 사용하여 코드를 모델링
- 일련의 구체적인 타입의 공통 기능을 식별
- 이러한 기능을 나타내는 인터페이스를 구축

마지막으로 해당 인터페이스를 사용하여 제네릭 코드를 작성하는 워크플로우를 살펴보겠습니다.

![](https://i.imgur.com/IlTgWym.png)


Swift의 추상화 도구에 대해 자세히 알아보고

농장 시뮬레이션을 위한 코드를 구축해보겠습니다.

## 구체적인 타입 작성

![](https://i.imgur.com/CGb5H6s.jpg)
요런 코드가 있다.

위 코드는 소에게 먹이를 줄 수 있는데 다른 동물 타입도 추가하고 싶다.

![](https://i.imgur.com/ucTdtrk.png)

Farm에서 소, 말, 닭에게 먹이를 주려고한다.

![](https://i.imgur.com/7BFF8PK.png)

각 파라미터 타입을 개별적으로 받아들이도록 feed 메서드를 오버로드할 수도 있지만 각 오버로드는 매우 비슷한 구현이 내부에 존재할 것이다.
![](https://i.imgur.com/M3cffoD.png)

이 구현은 더 많은 동물을 추가할수록 보일러플레이트 코드가 될 것이다.

반복적인 구현으로 오버로드를 작성하고 있다면 일반화하라는 신호일 수 있다.

## 동물 타입 간의 공통적인 기능을 식별
![](https://i.imgur.com/Ye1QkCs.png)

우리는 특정 타입의 먹이를 먹을 수 있는 동물 타입의 집합을 구축했다.
각 동물 타입은 먹는 방법이 다를 것이고 따라서 eat 메서드의 각 구현은 행동에서 차이가 있을 것이다.

여기서 추상 코드가 eat 메서드를 호출하도록 허용하고 추상 코드가 작동하는 구체적인 타입에 따라 다르게 동작하도록 구축하려고 한다.

추상 코드가 다양한 구체 타입에 따라 다르게 동작하는 능력을 다형성이라고 한다.

![](https://i.imgur.com/1FkWAOX.png)

다형성을 통해 코드 한 개는 사용되는 방식에 따라 여러 가지 동작을 가질 수 있다.

![](https://i.imgur.com/uvkkxJY.png)

다형성 자체는 다양한 형태로 나타난다.
- 오버로드
    - 같은 함수 호출은 인수 타입에 따라 다른 의미를 가질 수 있다. 
    - 오버로드는 실제로 일반적인 해결책이 아니므로 ad Hoc 다형성 이라고 부른다.
    - 오버로드는 반복적인 코드로 이어진다.
- 하위 타입 다형성
    - 슈퍼 타입에서 작동하는 코드는 런타임 시 코드가 사용하는 특정 하위 타입에 따라 다른 동작을 가질 수 있다.
- 제네릭을 사용하는 매개 변수 다형성
    - 제네릭 코드는 타입 매개변수를 사용하여 서로 다른 타입으로 작동하는 하나의 코드를 작성할 수 있고 구체적인 타입 자체가 인수로 사용된다.
    
오버로드는 제외하고 두개를 써보자

### 하위 타입 다형성

하위 타입 관계를 나타내는 한 가지 방법은 클래스 계층을 사용하는 것이다.

![](https://i.imgur.com/W0r0tXE.jpg)

이제 추상적인 동물 타입이 생겼고 이를 통해서 모든 특정 동물 타입을 나타낼 수 있다.
동물 타입에서 호출하는 eat 메서드는 하위 타입 다형성을 사용하여 하위 클래스 구현을 호출한다.

동물 타입에서 eat 메서드의 매개변수 타입을 아직 입력하지 않았으며 이 코드에서 몇 가지 다른 빨간색 플래그가 있다

클래스를 사용하면 서로 다른 동물 인스턴스 간에 어떤 상태도 공유할 필요가 없거나 공유하기 싫더라도 reference sementic을 사용하도록 강요한다.
또한 이 전략에는 기본 클래스의 메서드를 재정의하는 하위 클래스가 필요하지만 이 작업을 수행하는 것을 잊어도 런타임까지 탐지되지 않는다.

이 추상화의 가장 큰 문제는 각 동물의 하위 타입이 다른 종류의 음식을 먹는다는 것이다. 이 종속성은 클래스 계층으로 표현하기가 정말 어렵다

![](https://i.imgur.com/4kjzGOi.jpg)

우리가 선택할 수 있는 방법은 메서드가 Any와 같이 덜 구체적인 타입을 허용하게 하는 것이다. 

그러나 이 전략은 런타임에 올바른 타입이 전달됐는지 확인하기 위해 하위 클래스 구현에 의존한다.

그래서 우리는 각 하위 클래스의 메서드에 보일러 플레이트 코드를 추가로 부과했다. 이를 통해 우리가 우연히 잘못된 타입을 전달하게 되고 다른 버그가 생기지만 이걸 런타임에만 알아낼 수 있다

다른 방식으로 해보자

![](https://i.imgur.com/kDFb8u1.jpg)

대신 동물 슈퍼 클래스에 타입 매개변수를 도입하여 동물의 Feed 타입을 타입 안전 방식으로 표현할 수 있다

이 타입 매개변수는 각 하위 클래스에 대한 특정 Feed 타입의 플레이스 홀더 역할을 한다.

이 접근 방식에서는 Food 타입 매개 변수를 동물 클래스의 선언으로 높여야 한다.

동물들이 작동하려면 음식이 필요하긴 하지만 음식을 먹는 것이 동물의 핵심 목적은 아니며 동물들과 함께 작동하는 여러 코드들은 아마도 음식에 대해 전혀 신경쓰지 않기 때문에 부자연스럽다.

그렇다고 해도 동물 클래스에 대한 모든 참조는 음식 타입을 지정해야 한다.

예를들어 각 동물 하위 클래스는 상속 절의 각 꺾쇠괄호 안에 해당 음식 타입을 명시적으로 지정해줘야 한다.

![](https://i.imgur.com/191o6Ax.png)

동물 클래스의 각 사용 장소에 있는 이 보일러플레이트는 각 동물에 고유한 타입을 더 추가하는 경우 부담이 될 수 있다.

따라서 이러한 접근법은 좋지않다.

근본적인 문제는 클래스가 데이터 타입이라는 것이다.
또 우리는 슈퍼 클래스가 구체적인 타입에 대한 추상적인 아이디어를 나타내도록 만들기 위해 노력하고 있다. 

대신 우리는 기능의 작동 방식에 대한 세부정보 없이 타입의 기능을 나타내도록 설계된 언어 구조를 원한다. 

동물들에게는 두 가지 공통 기능이 있다.
각 동물에게는 특정 먹이 타입이 있으며 그 음식 중 일부를 소비하는 작업도 있다.

우리는 이러한 기능을 나타내는 인터페이스를 구축할 수 있다.

## 인터페이스 구축
Swift에서는 프로토콜을 사용하여 이를 수행한다.

![](https://i.imgur.com/PiHywQm.png)

프로토콜은 추상화 도구로 적합한 타입의 기능을 설명한다.
프로토콜을 사용하여 타입이 수행하는 작업에 대한 아이디어를 구현 세부 정보와 분리할 수 있다.
타입이 수행하는 작업에 대한 아이디어는 인터페이스를 통해 표현된다.

동물의 기능을 프로토콜 인터페이스로 변환해보자

![](https://i.imgur.com/EKvxhpr.png)

프로토콜 이름은 우리가 설명하는 타입의 범주를 나타낸다. 그래서 Animal로 짓는다.
각 기능은 프로토콜 요구 사항에 매핑된다.
특정 타입의 음식은 동물 프로토콜의 연관된 타입으로 매핑된다.
타입 파라미터와 마찬가지로 연관된 타입은 구체적인 타입의 플레이스 홀더 역할을 한다. 
연관된 타입이 특별한 이유는 프로토콜에 적합한 특정 타입에 따라 모두 다르기 때문이다.
이 관계는 보장되므로 특정 동물 타입의 각 인스턴스는 항상 동일한 먹이 타입을 먹는다.

다음으로 먹이를 소비하는 작업이 메서드에 매핑된다.

이제 각 구체 동물 타입이 프로토콜을 준수하게 만든다.

![](https://i.imgur.com/XOai1Gx.png)

동물 프로토콜의 연관된 값이 eat 메서드의 파라미터의 타입으로 사용되기 때문에 컴파일러가 타입을 추론할 수 있다.

이제 제네릭 코드를 작성할 수 있다.

## 제네릭 코드 작성

![](https://i.imgur.com/EjPSwhH.png)

우리는 동물 프로토콜을 사용하여 농장에서 먹이주기 메서드를 구현할 수 있다.

![](https://i.imgur.com/dRFDfAx.png)

매개변수 다형성을 사용하고 메서드가 호출될 때 구체적인 타입으로 대체될 타입 매개변수를 도입한다.

그리고 타입 매개변수에 제약을 준다. 제약은 위 그림처럼 할 수도 있고 where절 뒤에 작성할 수 있다.

![](https://i.imgur.com/2izax52.png)

feed 메서드에 초점을 맞춰보자

![](https://i.imgur.com/A0IXkSD.png)

타입 매개변수 A는 매개변수 목록에 한 번 나타나고 where 절은 타입 매개변수에 대한 제약? 요구사항을 나열한다.

이 경우 타입 매개변수의 이름을 지정하고 where 절을 사용하면 메서드가 실제보다 더 복잡해 보인다.

이 제네릭 패턴은 매우 일반적이어서 더 쉽게 표현할 수 있는 방법이 있다.

타입 매개변수를 명시적으로 쓰는 대신

![](https://i.imgur.com/rtJ2vA5.png)

요렇게 해줄 수 있다.

이 선언은 이전 선언과 동일하지만 불필요한 타입 매개변수 리스트, where 절이 사라졌다. 그들이 제공하는 표현력이 필요하지 않기 때문이다. 

some Animal로 작성하는게 더 간단하다. 

![](https://i.imgur.com/xPQS1DY.png)

얘를 좀 분석해보자

some은 우리가 현재 작업 중인 특정 타입이 있음을 나타낸다.

some 키워드는 적합성 요구사항 뒤에 나온다. 이 경우 특정 타입이 동물 프로토콜을 반드시 준수해야 하며 이를 통해 우리는 매개 변수 값에 동물 프로토콜의 요구 사항을 사용할 수 있다.

some 키워드는 매개 변수 및 결과 타입에 사용할 수 있다. 

![](https://i.imgur.com/VCoi7Hr.png)

스유를 써봤다면 사용했을 꺼임

![](https://i.imgur.com/F8zPU7x.png)

body 프로퍼티는 특정 타입의 뷰를 반환하지만 body 프로퍼티를 사용하는 코드는 특정 타입이 무엇인지 알 필요가 없다.


특정 구체적인 타입의 플레이스 홀더를 나타내는 추상 타입을 Opaque type이라고 한다.
대체되는 특정 구체적인 타입을 underling type이라고 한다.

Opaque 타입이 있는 값의 경우 값의 범위에 대해 기본 타입이 고정된다. 이렇게 하면 값을 사용하는 제네릭 코드는 값에 액세스할 때마다 동일한 기본 타입을 얻을 수 있다. 


![](https://i.imgur.com/uF2BDAN.png)

위에 나오는 두개 모두 Opaque 타입을 선언한다.

![](https://i.imgur.com/6z1fEs3.png)

Opaque 타입은 입력과 출력 모두에 사용할 수 있으므로 매개변수 위치 또는 결과 위치에서 선언할 수 있다.

Opaque 타입의 위치는 프로그램의 어떤 부분이 추상 타입을 보고 프로그램의 어떤 부분이 구체적인 타입을 결정하는지 결정한다.

타입 매개변수는 항상 입력 측에서 선언되므로 호출자는 기본 타입을 결정하고 구현은 추상 타입을 사용한다.

일반적으로 Opaque 파라미터 또는 결과 타입에 대한 값을 제공하는 프로그램의 부분이 기본 타입을 결정하고 이 값을 사용하는 곳에서 추상 타입을 본다.

기본 타입은 값에서 추론되므로 기본 타입은 항상 값과 동일한 위치에서 
나온다.

![](https://i.imgur.com/PSwOehM.png)

로컬 변수의 경우 기본 타입은 할당 오른쪽에 있는 값에서 추론된다.
즉 Opaque 타입의 로컬 변수는 항상 초기값을 가져야 한다!!!

이를 제공하지 않으면 컴파일러에서 에러를 발생시킨다.
![](https://i.imgur.com/1oRk82f.png)

변수 범위에 대해 기본 타입이 고정되어야 하므로 기본 타입을 변경하려고 해도 에러가 발생한다.
![](https://i.imgur.com/OSJvE2Y.png)

Opaque타입이 있는 파라미터의 경우 기본 타입은 호출 사이트의 인수 값에서 추론된다.

![](https://i.imgur.com/lYRF5F4.png)

파라미터 위치에서 사용하는 some은 Swift 5.7의 새 기능이다.
기본 타입은 파라미터의 범위에 대해서만 고정되면 된다.

![](https://i.imgur.com/vSiNzCT.png)

따라서 각 호출은 서로 다른 인수 타입을 제공할 수 있다.

Opaque 결과 타입의 경우 기본 타입은 구현의 반환 값에서 추론된다.

![](https://i.imgur.com/GEtU7t9.png)

Opaque 결과 타입을 가진 메서드 또는 computed 프로퍼티는 프로그램의 모든 위치에서 호출할 수 있으므로 이 명명된 값의 범위는 전역적이다. 즉, 기본 반환 타입은 모든 반환 구문에서 동일해야 한다.

그렇지 않으면 컴파일러는 기본 반환 값의 타입이 일치하지 않는다는 에러를 발생시킨다. 
![](https://i.imgur.com/RSUZcDg.png)

Opaque 스유 뷰의 경우 ViewBuilder DSL은 각 분기에 대해 동일한 기본 반환 타입을 갖도록 제어 흐름 구문을 변환할 수 있다.

![](https://i.imgur.com/L4aH4Bl.png)

따라서 이 경우 ViewBuilder DSL을 사용하여 문제를 해결할 수 있다. 
@ViewBuilder 붙이고 리턴지우면 ViewBuilder 타입별로 결과를 빌드할 수 있다고 함

feedAnimal 메서드로 돌아가보자

Opaque 타입을 다른 곳에서 참조할 필요가 없으므로 파라미터 목록에서 some을 사용할 수 있다. 함수 시그니쳐에서 Opaque 타입을 여러 번 참조해야 하는 경우 타입 파라미터가 유용하게 사용된다. 

예를 들어 우리가 동물 프로토콜에 다른 연관된 타입을 추가하면 
![](https://i.imgur.com/rvjhBGX.png)

우리는 어떤 동물을 위해 농장에 서식지를 만들 수 있기를 원할 수도 있다. 이 경우 특정 동물 타입에 따라 결과 타입이 달라지기 때문에 
파라미터 타입과 반환 타입에 타입 매개변수 A를 사용해야 한다.

Opaque 타입을 여러 번 참조해야 하는 또 다른 일반적인 위치는 제네릭 타입이다. 코드는 종종 제네릭 타입에 타입 파라미터를 선언하고 프로퍼티에 사용하고 memberwise initializer에서 다시 사용한다.

![](https://i.imgur.com/cREBhI7.png)

다른 맥락에서 제네릭 타입을 참조하려면 꺾쇠괄호 안에 타입 파라미터를 명시적으로 지정해야 한다.
선언의 꺾쇠괄호는 제네릭 타입을 사용하는 방법을 명확히 하는 데 도움이 되므로 Opaque 타입은 제네릭 타입에 대해 항상 이름을 지정해야 한다.

이제 feed 메서드의 구현을 구축해보자

![](https://i.imgur.com/9Y9gy0j.png)

동물 매개변수의 타입을 사용하여 Feed 연관된 타입을 통해 재배할 작물 타입에 액세스할 수 있다.

![](https://i.imgur.com/mspd1Sv.png)

다음으로 crop로 부터 농작물을 수확해야 하는데 crop이 제공하는 harvest 메서드를 호출하여 수행할 수 있다.

![](https://i.imgur.com/ezoW2Bh.png)

마지막으로 이 농작물을 동물에게 먹일 수 있다.

![](https://i.imgur.com/I2KD2tt.png)

기본 동물 타입이 고정되어 있기 때문에 컴파일러는 다양한 메서드 호출에 걸쳐 식물 타입과 생산물 타입 동물 타입 간의 관계를 알 고 있다.
이러한 정적 관계는 우리가 동물에게 잘못된 종류의 음식을 먹이는 실수를 저지르지 못하게 막는다.

![](https://i.imgur.com/BPtmlEm.png)

우리가 이 동물에 대해 정확한 먹이 타입으로 보장되지 않는 타입을 사용하려고 한다면 컴파일러는 알려준다.

마지막으로 모든 동물에게 먹이를 주는 메서드를 추가해보자

![](https://i.imgur.com/sZIKCYU.png)

배열을 받아들이는 feedAll 메서드를 추가한다.

요소 타입이 동물 프로토콜을 따라야 한다는 것은 알지만 배열이 다른 동물 타입을 저장하고 싶다.

![](https://i.imgur.com/MJXHI0G.png) 

some Animal로 우리의 요구사항을 충족할 수 있는지 알아보자

![](https://i.imgur.com/gwiNoWG.png)

some에는 변경할 수 없는 특정 기본 타입이있다.

기본 타입은 고정되므로 배열의 모든 요소가 동일한 타입을 가져야한다.

그래서 some Animal의 배열은 요구사항을 충족하지 못한다.

여기서 우리는 모든 동물 타입을 대표할 수 있는 슈퍼 타입이 반드시 필요하다. 

![](https://i.imgur.com/37ajBYC.png)

얘로 그걸 표현할 수 있다.

any 키워드는 이 타입이 임의의 동물 타입을 저장할 수 있으며 기본 동물 타입은 런타임에 달라질 수 있음을 나타낸다. 

some 키워드와 마찬가지로 any 키워드는 적합성 요구 사항 뒤에 나온다. 

any Animal은 모든 구체적인 동물 타입을 동적으로 저장할 수 있는 단일 정적 타입으로 값 타입을 가진 하위 타입 다형성을 사용할 수 있다.

이러한 유연한 스토리지를 허용하기 위해 모든 동물 타입은 메모리에 특별한 표현을 가진다.

![](https://i.imgur.com/AGqDR72.png)

이 표현을 상자처럼 생각할 수 있다.

![](https://i.imgur.com/DQUiXyl.png)

값이 상자안에 직접 들어갈 정도로 작은 경우도 가끔 있다.

또 어떤 값은 상자에 넣기에 너무 커서 값을 다른 곳에 할당해야 하고 상자에는 해당 값에 대한 포인터가 저장된다. 

모든 구체적인 동물 타입을 동적으로 저장할 수 있는 정적 타입 any Animal을 공식적으로 Existential type으로 부른다.

다른 구체적인 타입에 대해 동일한 표현을 사용하는 전략을 type erasure라고 한다. 구체적인 타입은 컴파일 시 소거된다고 하며 구체적인 타입은 런타임 시에만 알려진다.

Existential type any Animal의 이 두 인스턴스는 정적 타입이 같지만 동적 타입이 다르다. 

![](https://i.imgur.com/XwTBg89.png)

타입 소거는 서로 다른 동물 값 사이의 타입 수준 구분을 제거하며 이를 통해 서로 다른 동적 타입을 가진 값을 동일한 정적 타입으로 상호 교환하여 사용할 수 있다.

유형 소거를 사용하여 feedAll 메서드에서 원하는 값 타입의 이기종 배열을 작성할 수 있다. 

![](https://i.imgur.com/tPgGRHi.png)

우리는 any Animal 배열을 매개 변수 타입으로 사용한다.

연관된 타입이 있는 프로토콜에 any 키워드를 사용하는 것은 Swift 5.7의 새로운 기능이다.

이제 내부 구현을 시작

먼저 동물 배열을 반복한다.
동물 프로토콜에서 각 동물에 대해 eat 메서드를 호출하려고 한다.
이 메서드를 호출하려면 이 반복에서 기본 동물을 위한 특정 Feed타입을 얻을 필요가 있다.

하지만 any Animal에서 eat를 호출하려고 하면 컴파일 에러가 발생한다.

![](https://i.imgur.com/JJjgUNL.png)

특정 동물 타입 간의 타입 수준의 구분을 제거했기 때문이다.
우리는 특정 동물 타임에 따라서 달라지는 모든 타입의 관계도 제거했다. 연관된 타입을 포함해서!!

그래서 이 동물이 어떤 타입의 사료를 기대하는지 알 수 없다.

타입 관계에 의존하려면 특정 타입의 동물이 고정된 맥락으로 돌아갈 필요가 있다.

모든 동물에서 직접 먹기를 호출하는 대신 some Animal을 수락하는 feed 메서드를 호출해야 한다.

![](https://i.imgur.com/yo2otu2.png)

any Animal은 some Animal고 다른 타입이지만 컴파일러는 기본값을 언박싱하고 some Animal 매개변수에 이를 직접 전달하여 모든 동물의 인스턴스를 some Animal로 변환할 수 있다. 

![](https://i.imgur.com/nv49DVc.png)

이러한 언박싱 인수 기능은 Swift 5.7의 새로운 기능이다.
우리는 언박싱이 컴파일러가 상자를 열고 내부에 저장된 값을 꺼내는 행위라고 생각할 수 있다. some Animal 파라미터 범위의 경우 값은 고정된 기본 타입을 가지므로 연관된 타입에 대한 액세스를 포함하여 기본 타입에 대한 모든 작업에 액세스할 수 있다.

이 기능은 우리가 필요할 때 유연한 스토리지를 선택할 수 있도록 허용하는 동시에 함수 범위에 대한 기본 타입을 수정하여 정적 타입 시스템의 완전한 표현성을 제공하는 맥락으로 돌아갈 수 있게 하므로 매우 유용하다.

또 대부분의 경우 언박싱에 대해 생각할 필요가 없다.
언박싱은 우리가 예상하는 대로 작동하기 때문이다.
any 동물에서 프로토콜 메서드를 호출하는 것은 실제로 기본 타입에서 메서드를 호출하는 것과 비슷하다. 

![](https://i.imgur.com/Aq2VL72.png)

따라서 feed 메서드로 각 동물을 전달할 수 있으며 이 메서드에서 각 반복에서 특정 동물들에게 먹일 적절한 작물을 재배하고 수확할 수 있다.

이 과정을 통해 some과 any의 서로 다른 기능을 지녔다는 것을 확인했다. 

![](https://i.imgur.com/Lc0AzTX.png)

some을 사용하면 기본 타입이 고정된다.
이를 통해 제네릭 타입의 기본 타입에 대한 타입 관계에 의존할 수 있다

따라서 작업 중인 프로토콜의 API 및 연관된 타입에 대한 전체 액세스를 갖게 된다.

임의의 구체적인 타입을 저장할 경우 any를 사용한다.
any는 타입 소거를 제공한다.
이를 통해 이기종 컬렉션을 나타내고 기본 타입의 부재를 나타내며 옵셔널을 사용하고 추상화를 구현 세부 정보로 만든다.

일반적으로 기본값으로 some을 작성하고 임의 값을 저장해야 할 경우 some을 any로 변경한다.

![](https://i.imgur.com/AIiglEx.png)

이 접근법을 사용하면 우리의 스토리지 유연성이 필요한 경우에만 타입 소거 비용과 의미 제한에 대한 비용을 지불하면 된다. 이 워크플로우는 변환이 필요하다는걸 알 때까지 기본값으로 let을 작성하는 것과 유사하다. some을 기본으로 붙이자!!

